{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My-SQL-Journey Embarking on the SQL Learning Path This repository documents my personal journey to master Structured Query Language (SQL) through hands-on practice. The primary source of exercises and challenges comes from LeetCode's SQL problem set. The goal is not just to solve problems, but to deeply understand the underlying concepts and develop proficiency in writing efficient and effective SQL queries. Each solved LeetCode problem will be committed to this repository with: Clear and well-commented SQL code: Explaining the logic and reasoning behind the solution. Potentially multiple solutions: Exploring different approaches and their trade-offs. Reflections and insights: Sharing what I learned from the problem and any challenges encountered. What You'll Find Here As this journey progresses, you'll find solutions covering a wide range of SQL topics, including: Basic Queries: CREATE , INSERT , SELECT , FROM , WHERE , ORDER BY , LIMIT , DISTINCT Filtering and Sorting: Using operators like AND , OR , NOT , IN , BETWEEN , LIKE Aggregate Functions: COUNT() , SUM() , AVG() , MIN() , MAX() , GROUP BY , HAVING Joins: INNER JOIN , LEFT JOIN , RIGHT JOIN , FULL OUTER JOIN Subqueries: Using queries within other queries Set Operations: UNION , UNION ALL , INTERSECT , EXCEPT Window Functions: Performing calculations across a set of table rows Schema Design Considerations: Thoughts on table structures and relationships (where applicable in problem context) Optimization Techniques: Exploring ways to write more performant SQL (when relevant to the problem) Potentially explorations of different SQL dialects: (e.g., MySQL, PostgreSQL, SQLite - depending on LeetCode problem context) Progress Tracking: Observing the evolution of my SQL skills over time. Who Might Find This Useful? Fellow SQL Learners: You can follow my progress, compare your solutions, and potentially learn from my insights and mistakes. Aspiring Data Analysts and Engineers: Get a practical view of how SQL is used to solve real-world-like problems. Developers Looking to Brush Up on SQL: See practical examples of various SQL concepts in action. Anyone Curious About the Process of Learning SQL: Witness the journey of building SQL proficiency through consistent practice. How to Navigate This Repository Each LeetCode problem will likely have its own clearly named file. The filenames will ideally correspond to the LeetCode problem number and title for easy reference. Comments within the SQL files will provide explanations and context. Join the Journey! Feel free to explore the solutions, provide feedback, or even suggest alternative approaches. Learning is a collaborative process, and I welcome any constructive input. Let's learn SQL together! License This repository is licensed under the MIT License . Contact [diptunazmulalam@gmail.com] Nazmul Alam Diptu","title":"Home"},{"location":"#my-sql-journey","text":"","title":"My-SQL-Journey"},{"location":"#embarking-on-the-sql-learning-path","text":"This repository documents my personal journey to master Structured Query Language (SQL) through hands-on practice. The primary source of exercises and challenges comes from LeetCode's SQL problem set. The goal is not just to solve problems, but to deeply understand the underlying concepts and develop proficiency in writing efficient and effective SQL queries. Each solved LeetCode problem will be committed to this repository with: Clear and well-commented SQL code: Explaining the logic and reasoning behind the solution. Potentially multiple solutions: Exploring different approaches and their trade-offs. Reflections and insights: Sharing what I learned from the problem and any challenges encountered.","title":"Embarking on the SQL Learning Path"},{"location":"#what-youll-find-here","text":"As this journey progresses, you'll find solutions covering a wide range of SQL topics, including: Basic Queries: CREATE , INSERT , SELECT , FROM , WHERE , ORDER BY , LIMIT , DISTINCT Filtering and Sorting: Using operators like AND , OR , NOT , IN , BETWEEN , LIKE Aggregate Functions: COUNT() , SUM() , AVG() , MIN() , MAX() , GROUP BY , HAVING Joins: INNER JOIN , LEFT JOIN , RIGHT JOIN , FULL OUTER JOIN Subqueries: Using queries within other queries Set Operations: UNION , UNION ALL , INTERSECT , EXCEPT Window Functions: Performing calculations across a set of table rows Schema Design Considerations: Thoughts on table structures and relationships (where applicable in problem context) Optimization Techniques: Exploring ways to write more performant SQL (when relevant to the problem) Potentially explorations of different SQL dialects: (e.g., MySQL, PostgreSQL, SQLite - depending on LeetCode problem context) Progress Tracking: Observing the evolution of my SQL skills over time.","title":"What You'll Find Here"},{"location":"#who-might-find-this-useful","text":"Fellow SQL Learners: You can follow my progress, compare your solutions, and potentially learn from my insights and mistakes. Aspiring Data Analysts and Engineers: Get a practical view of how SQL is used to solve real-world-like problems. Developers Looking to Brush Up on SQL: See practical examples of various SQL concepts in action. Anyone Curious About the Process of Learning SQL: Witness the journey of building SQL proficiency through consistent practice.","title":"Who Might Find This Useful?"},{"location":"#how-to-navigate-this-repository","text":"Each LeetCode problem will likely have its own clearly named file. The filenames will ideally correspond to the LeetCode problem number and title for easy reference. Comments within the SQL files will provide explanations and context.","title":"How to Navigate This Repository"},{"location":"#join-the-journey","text":"Feel free to explore the solutions, provide feedback, or even suggest alternative approaches. Learning is a collaborative process, and I welcome any constructive input. Let's learn SQL together!","title":"Join the Journey!"},{"location":"#license","text":"This repository is licensed under the MIT License .","title":"License"},{"location":"#contact","text":"[diptunazmulalam@gmail.com] Nazmul Alam Diptu","title":"Contact"},{"location":"reference/","text":"\ud83d\udcda References MySQL CREATE Database Tutorial \u2013 MySQL Tutorial","title":"Refference"},{"location":"reference/#references","text":"MySQL CREATE Database Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/","text":"My-SQL-Journey This document chronicles my experiences and lessons learned while working with MySQL, including tips, best practices, and common pitfalls. Table of Contents Section 1:CREATE STATEMENT Subsection 1.1: CREATE Database Subsection 1.2: CREATE Table Section 1:INSERT STATEMENT Subsection 2.1: INSERT Single Row Subsection 2.2: INSERT Multiple Row Section 1:SELECT Subsection 3.1: SELECT PART 01 Subsection 3.2: SELECT PART 02 List: 1683. Invalid Tweets","title":"tutorials"},{"location":"tutorials/#my-sql-journey","text":"This document chronicles my experiences and lessons learned while working with MySQL, including tips, best practices, and common pitfalls.","title":"My-SQL-Journey"},{"location":"tutorials/#table-of-contents","text":"Section 1:CREATE STATEMENT Subsection 1.1: CREATE Database Subsection 1.2: CREATE Table Section 1:INSERT STATEMENT Subsection 2.1: INSERT Single Row Subsection 2.2: INSERT Multiple Row Section 1:SELECT Subsection 3.1: SELECT PART 01 Subsection 3.2: SELECT PART 02 List: 1683. Invalid Tweets","title":"Table of Contents"},{"location":"tutorials/1517/","text":"1517. Find Users With Valid E-Mails Problem Statement Write a solution to find the users who have valid emails. A valid e-mail has a prefix name and a domain where: The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.', and/or dash '-'. The prefix name must start with a letter. The domain is '@leetcode.com'. Return the result table in any order. Solution This query retrieves user information (user_id, name, mail) from the Users table, but only for users with an email address that matches the pattern of being a valid LeetCode email (@leetcode.com). It is a great example of how regular expressions can be used in SQL to filter data with complex patterns! query:01 SELECT user_id , name , mail FROM Users WHERE mail REGEXP '^[a-zA-Z]{1}[a-zA-Z0-9_.-]*@leetcode[.]com$' \ud83d\udcc8 Breakdown of the Query Part of Regex Explanation ^ Anchors the start of the string. Ensures the email starts from the first character. [a-zA-Z]{1} Matches 1 alphabet character (either lowercase or uppercase). This is the first character of the email before the @ symbol. [a-zA-Z0-9_.-]* Matches any sequence (including none) of the following characters: lowercase or uppercase letters ( a-zA-Z ), digits ( 0-9 ), and special characters like underscore ( _ ), period ( . ), or hyphen ( - ). [.] [.] : This matches the literal dot (.) character query:02 \u2705 SELECT * FROM Users WHERE REGEXP_LIKE ( mail , '^[A-Za-z]+[A-Za-z0-9\\_\\.\\-]*@leetcode\\\\.com$' ); Key Differences: REGEXP_LIKE vs REGEXP : REGEXP_LIKE is a more performance-optimized function for matching patterns, especially for cases like validating emails, and is often faster than the more generic REGEXP function. The improved internal optimizations and potential caching mechanisms in REGEXP_LIKE allow it to perform better, especially when dealing with complex patterns or repeated queries. The pattern itself is similar in both queries, but REGEXP_LIKE is designed to handle matching more efficiently in most modern MySQL setups (starting from version 8.0).","title":"1517"},{"location":"tutorials/1517/#problem-statement","text":"Write a solution to find the users who have valid emails. A valid e-mail has a prefix name and a domain where: The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.', and/or dash '-'. The prefix name must start with a letter. The domain is '@leetcode.com'. Return the result table in any order.","title":"Problem Statement"},{"location":"tutorials/1517/#solution","text":"This query retrieves user information (user_id, name, mail) from the Users table, but only for users with an email address that matches the pattern of being a valid LeetCode email (@leetcode.com). It is a great example of how regular expressions can be used in SQL to filter data with complex patterns! query:01 SELECT user_id , name , mail FROM Users WHERE mail REGEXP '^[a-zA-Z]{1}[a-zA-Z0-9_.-]*@leetcode[.]com$'","title":"Solution"},{"location":"tutorials/1517/#breakdown-of-the-query","text":"Part of Regex Explanation ^ Anchors the start of the string. Ensures the email starts from the first character. [a-zA-Z]{1} Matches 1 alphabet character (either lowercase or uppercase). This is the first character of the email before the @ symbol. [a-zA-Z0-9_.-]* Matches any sequence (including none) of the following characters: lowercase or uppercase letters ( a-zA-Z ), digits ( 0-9 ), and special characters like underscore ( _ ), period ( . ), or hyphen ( - ). [.] [.] : This matches the literal dot (.) character query:02 \u2705 SELECT * FROM Users WHERE REGEXP_LIKE ( mail , '^[A-Za-z]+[A-Za-z0-9\\_\\.\\-]*@leetcode\\\\.com$' );","title":"\ud83d\udcc8 Breakdown of the Query"},{"location":"tutorials/1517/#key-differences","text":"REGEXP_LIKE vs REGEXP : REGEXP_LIKE is a more performance-optimized function for matching patterns, especially for cases like validating emails, and is often faster than the more generic REGEXP function. The improved internal optimizations and potential caching mechanisms in REGEXP_LIKE allow it to perform better, especially when dealing with complex patterns or repeated queries. The pattern itself is similar in both queries, but REGEXP_LIKE is designed to handle matching more efficiently in most modern MySQL setups (starting from version 8.0).","title":"Key Differences:"},{"location":"tutorials/1683/","text":"1683. Invalid Tweets Problem Statement Write a solution to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15. Return the result table in any order. Solution The provided solution utilizes a simple SELECT statement combined with a length checking function: SELECT tweet_id FROM Tweets WHERE LENGTH ( content ) > 15 ; \ud83e\udde0 Explanation SELECT tweet_id : Specifies that we want to retrieve the tweet_id column. FROM Tweets : The query fetches data from the table named Tweets . WHERE LENGTH(content) > 15 : The LENGTH() function calculates the number of characters in the content field. The WHERE clause filters the results to include only those rows where the content has more than 15 characters.","title":"1683"},{"location":"tutorials/1683/#problem-statement","text":"Write a solution to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is strictly greater than 15. Return the result table in any order.","title":"Problem Statement"},{"location":"tutorials/1683/#solution","text":"The provided solution utilizes a simple SELECT statement combined with a length checking function: SELECT tweet_id FROM Tweets WHERE LENGTH ( content ) > 15 ;","title":"Solution"},{"location":"tutorials/1683/#explanation","text":"SELECT tweet_id : Specifies that we want to retrieve the tweet_id column. FROM Tweets : The query fetches data from the table named Tweets . WHERE LENGTH(content) > 15 : The LENGTH() function calculates the number of characters in the content field. The WHERE clause filters the results to include only those rows where the content has more than 15 characters.","title":"\ud83e\udde0 Explanation"},{"location":"tutorials/1907/","text":"1907. Count Salary Categories Problem Statement Write a solution to calculate the number of bank accounts for each salary category. The salary categories are: \"Low Salary\": All the salaries strictly less than $20000. \"Average Salary\": All the salaries in the inclusive range [$20000, $50000]. \"High Salary\": All the salaries strictly greater than $50000. The result table must contain all three categories. If there are no accounts in a category, return 0. Return the result table in any order. \ud83d\udcca SQL Query: Categorizing Accounts Based on Salary Ranges This query categorizes accounts into three groups based on income: Low Salary , Average Salary , and High Salary . It counts the number of accounts in each category by using CASE WHEN statements to evaluate income ranges and then combines the results using UNION ALL . \ud83e\uddd0 Solution query01 SELECT 'Low Salary' AS category , COUNT ( CASE WHEN income < 20000 THEN 1 END ) AS accounts_count FROM Accounts UNION ALL SELECT 'Average Salary' AS category , COUNT ( CASE WHEN income >= 20000 AND income <= 50000 THEN 1 END ) AS accounts_count FROM Accounts UNION ALL SELECT 'High Salary' AS category , COUNT ( CASE WHEN income > 50000 THEN 1 END ) AS accounts_count FROM Accounts ; \ud83d\udccb Explanation Breakdown 1. First SELECT Statement (Low Salary) Purpose : Categorizes accounts with an income less than 20,000 as 'Low Salary' . Explanation : 'Low Salary' AS category : This assigns the label 'Low Salary' to the first group. COUNT(CASE WHEN income < 20000 THEN 1 END) AS accounts_count : Counts the number of accounts where the income is less than 20,000. The CASE WHEN expression returns 1 for rows where the condition is true, and COUNT() aggregates those rows. 2. Second SELECT Statement (Average Salary) Purpose : Categorizes accounts with an income between 20,000 and 50,000 as 'Average Salary' . Explanation : 'Average Salary' AS category : This assigns the label 'Average Salary' to the second group. COUNT(CASE WHEN income >= 20000 AND income <= 50000 THEN 1 END) AS accounts_count : Counts the number of accounts where the income is between 20,000 and 50,000. The CASE WHEN expression checks if the income falls within the range, and COUNT() tallies those rows. 3. Third SELECT Statement (High Salary) Purpose : Categorizes accounts with an income greater than 50,000 as 'High Salary' . Explanation : 'High Salary' AS category : This assigns the label 'High Salary' to the third group. COUNT(CASE WHEN income > 50000 THEN 1 END) AS accounts_count : Counts the number of accounts where the income is greater than 50,000. The CASE WHEN expression checks if the income is above 50,000, and COUNT() aggregates those rows. 4. UNION ALL Purpose : Combines the results from the three SELECT statements into a single result set. Explanation : UNION ALL combines the results of each SELECT without removing duplicates. This is appropriate here because we want to include all the categories (Low Salary, Average Salary, and High Salary) without filtering out any duplicate rows. Important : UNION ALL preserves the original counts and groups, whereas UNION would remove duplicates, which is unnecessary in this case. Query 01 is slower Multiple Full Table Scans: Query01 performs three separate full table scans for each of the UNION ALL subqueries. Each subquery scans the entire Accounts table and applies different conditions (income ranges) to count the rows. This means that the table is being scanned three times\u2014once for each salary category. This increases the execution time, especially for large datasets. Multiple COUNT Calculations: In each of the subqueries, the COUNT function is used along with a CASE statement to evaluate conditions and count rows. The entire Accounts table must be evaluated for each CASE statement independently. For larger datasets, this repeated evaluation of the same table leads to unnecessary redundancy and inefficiency query02\u2705 WITH counts AS ( SELECT SUM ( CASE WHEN income < 20000 THEN 1 ELSE 0 END ) AS low_salary , SUM ( CASE WHEN income BETWEEN 20000 AND 50000 THEN 1 ELSE 0 END ) AS average_salary , SUM ( CASE WHEN income > 50000 THEN 1 ELSE 0 END ) AS high_salary FROM Accounts ) SELECT 'Low Salary' AS category , low_salary AS accounts_count FROM counts UNION ALL SELECT 'Average Salary' , average_salary FROM counts UNION ALL SELECT 'High Salary' , high_salary FROM counts ; \ud83d\ude80 Why the Query02 is Faster: Single Table Scan: Query02 performs a single scan of the Accounts table inside the WITH clause (common table expression, CTE). This query calculates the sum of accounts that match each salary range (low_salary, average_salary, high_salary). Instead of scanning the table multiple times for each range, the table is scanned once, and all calculations are done in that single pass. This significantly reduces the overhead compared to Query01. Aggregation within a Single Query: In Query02, the SUM function is used to count the accounts in each salary range within a single aggregation step. This avoids the need for multiple CASE statements and COUNT functions across multiple subqueries, reducing the total computation time. The results for all three categories are computed in one pass, making it faster for larger datasets. Use of CTE (Common Table Expression): The CTE in Query02 aggregates all the counts first, and then the individual categories are selected from the aggregated results using a simple UNION ALL. The aggregation (SUM) is performed once, and then the result is reused for each category, making the overall query much more efficient. \ud83c\udfafKey Performance Differences: Query01 requires multiple table scans (one for each category), while - Query02 performs only a single table scan. Query01 calculates counts in separate subqueries, which means the table is processed multiple times. Query02 does all the calculations in a single aggregation step, minimizing redundancy. Query02 uses a CTE to perform all the calculations upfront and then retrieves the results efficiently, whereas Query01 performs the COUNT function and conditions multiple times.","title":"1907"},{"location":"tutorials/1907/#problem-statement","text":"Write a solution to calculate the number of bank accounts for each salary category. The salary categories are: \"Low Salary\": All the salaries strictly less than $20000. \"Average Salary\": All the salaries in the inclusive range [$20000, $50000]. \"High Salary\": All the salaries strictly greater than $50000. The result table must contain all three categories. If there are no accounts in a category, return 0. Return the result table in any order.","title":"Problem Statement"},{"location":"tutorials/1907/#sql-query-categorizing-accounts-based-on-salary-ranges","text":"This query categorizes accounts into three groups based on income: Low Salary , Average Salary , and High Salary . It counts the number of accounts in each category by using CASE WHEN statements to evaluate income ranges and then combines the results using UNION ALL .","title":"\ud83d\udcca SQL Query: Categorizing Accounts Based on Salary Ranges"},{"location":"tutorials/1907/#solution","text":"query01 SELECT 'Low Salary' AS category , COUNT ( CASE WHEN income < 20000 THEN 1 END ) AS accounts_count FROM Accounts UNION ALL SELECT 'Average Salary' AS category , COUNT ( CASE WHEN income >= 20000 AND income <= 50000 THEN 1 END ) AS accounts_count FROM Accounts UNION ALL SELECT 'High Salary' AS category , COUNT ( CASE WHEN income > 50000 THEN 1 END ) AS accounts_count FROM Accounts ;","title":"\ud83e\uddd0 Solution"},{"location":"tutorials/1907/#explanation-breakdown","text":"","title":"\ud83d\udccb Explanation Breakdown"},{"location":"tutorials/1907/#1-first-select-statement-low-salary","text":"Purpose : Categorizes accounts with an income less than 20,000 as 'Low Salary' . Explanation : 'Low Salary' AS category : This assigns the label 'Low Salary' to the first group. COUNT(CASE WHEN income < 20000 THEN 1 END) AS accounts_count : Counts the number of accounts where the income is less than 20,000. The CASE WHEN expression returns 1 for rows where the condition is true, and COUNT() aggregates those rows.","title":"1. First SELECT Statement (Low Salary)"},{"location":"tutorials/1907/#2-second-select-statement-average-salary","text":"Purpose : Categorizes accounts with an income between 20,000 and 50,000 as 'Average Salary' . Explanation : 'Average Salary' AS category : This assigns the label 'Average Salary' to the second group. COUNT(CASE WHEN income >= 20000 AND income <= 50000 THEN 1 END) AS accounts_count : Counts the number of accounts where the income is between 20,000 and 50,000. The CASE WHEN expression checks if the income falls within the range, and COUNT() tallies those rows.","title":"2. Second SELECT Statement (Average Salary)"},{"location":"tutorials/1907/#3-third-select-statement-high-salary","text":"Purpose : Categorizes accounts with an income greater than 50,000 as 'High Salary' . Explanation : 'High Salary' AS category : This assigns the label 'High Salary' to the third group. COUNT(CASE WHEN income > 50000 THEN 1 END) AS accounts_count : Counts the number of accounts where the income is greater than 50,000. The CASE WHEN expression checks if the income is above 50,000, and COUNT() aggregates those rows.","title":"3. Third SELECT Statement (High Salary)"},{"location":"tutorials/1907/#4-union-all","text":"Purpose : Combines the results from the three SELECT statements into a single result set. Explanation : UNION ALL combines the results of each SELECT without removing duplicates. This is appropriate here because we want to include all the categories (Low Salary, Average Salary, and High Salary) without filtering out any duplicate rows. Important : UNION ALL preserves the original counts and groups, whereas UNION would remove duplicates, which is unnecessary in this case.","title":"4. UNION ALL"},{"location":"tutorials/1907/#query-01-is-slower","text":"Multiple Full Table Scans: Query01 performs three separate full table scans for each of the UNION ALL subqueries. Each subquery scans the entire Accounts table and applies different conditions (income ranges) to count the rows. This means that the table is being scanned three times\u2014once for each salary category. This increases the execution time, especially for large datasets. Multiple COUNT Calculations: In each of the subqueries, the COUNT function is used along with a CASE statement to evaluate conditions and count rows. The entire Accounts table must be evaluated for each CASE statement independently. For larger datasets, this repeated evaluation of the same table leads to unnecessary redundancy and inefficiency query02\u2705 WITH counts AS ( SELECT SUM ( CASE WHEN income < 20000 THEN 1 ELSE 0 END ) AS low_salary , SUM ( CASE WHEN income BETWEEN 20000 AND 50000 THEN 1 ELSE 0 END ) AS average_salary , SUM ( CASE WHEN income > 50000 THEN 1 ELSE 0 END ) AS high_salary FROM Accounts ) SELECT 'Low Salary' AS category , low_salary AS accounts_count FROM counts UNION ALL SELECT 'Average Salary' , average_salary FROM counts UNION ALL SELECT 'High Salary' , high_salary FROM counts ;","title":"Query 01 is slower"},{"location":"tutorials/1907/#why-the-query02-is-faster","text":"Single Table Scan: Query02 performs a single scan of the Accounts table inside the WITH clause (common table expression, CTE). This query calculates the sum of accounts that match each salary range (low_salary, average_salary, high_salary). Instead of scanning the table multiple times for each range, the table is scanned once, and all calculations are done in that single pass. This significantly reduces the overhead compared to Query01. Aggregation within a Single Query: In Query02, the SUM function is used to count the accounts in each salary range within a single aggregation step. This avoids the need for multiple CASE statements and COUNT functions across multiple subqueries, reducing the total computation time. The results for all three categories are computed in one pass, making it faster for larger datasets. Use of CTE (Common Table Expression): The CTE in Query02 aggregates all the counts first, and then the individual categories are selected from the aggregated results using a simple UNION ALL. The aggregation (SUM) is performed once, and then the result is reused for each category, making the overall query much more efficient. \ud83c\udfafKey Performance Differences: Query01 requires multiple table scans (one for each category), while - Query02 performs only a single table scan. Query01 calculates counts in separate subqueries, which means the table is processed multiple times. Query02 does all the calculations in a single aggregation step, minimizing redundancy. Query02 uses a CTE to perform all the calculations upfront and then retrieves the results efficiently, whereas Query01 performs the COUNT function and conditions multiple times.","title":"\ud83d\ude80 Why the Query02 is Faster:"},{"location":"tutorials/1934/","text":"1934. Confirmation Rate Problem Statement The confirmation rate of a user is the number of 'confirmed' messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places. Write a solution to find the confirmation rate of each user. Return the result table in any order. Solution \ud83d\udcca Explanation of the SQL Query This SQL query calculates the confirmation rate for each user by determining the percentage of \"confirmed\" actions out of all possible actions for each user. The query uses the RIGHT JOIN to ensure all users from the Signups table are included, even if there is no corresponding record in the Confirmations table. query01 SELECT user_id , ROUND ( AVG ( CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END ), 2 ) AS confirmation_rate FROM Confirmations RIGHT JOIN Signups USING ( user_id ) GROUP BY user_id ; \ud83d\udcc8 Breakdown of the Query \ud83d\udd0eSQL Query Breakdown 1. SELECT user_id, Purpose : Selects the user_id column from the result set. Explanation : This part of the query retrieves the unique identifier for each user in the final result. 2. ROUND(AVG(CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END), 2) AS confirmation_rate Purpose : Calculates the confirmation rate for each user and rounds the result to 2 decimal places. Explanation : CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END : This conditional expression checks if the action is 'confirmed' . If the action is 'confirmed' , it returns 1 . Otherwise, it returns 0 . AVG() : The AVG() function calculates the average of the 1 s and 0 s, effectively computing the confirmation rate. The confirmation rate is the percentage of times the action was 'confirmed' compared to all actions for each user. ROUND(..., 2) : This rounds the calculated average (confirmation rate) to 2 decimal places , making the result more readable. AS confirmation_rate : Aliases the resulting column as confirmation_rate , which will be used in the output. 3. FROM Confirmations Purpose : Specifies the source table for the data. Explanation : The query retrieves data from the Confirmations table, which stores records of user actions, such as whether an action was confirmed. 4. RIGHT JOIN Signups USING (user_id) Purpose : Performs a RIGHT JOIN between the Confirmations table and the Signups table using the user_id column. Explanation : RIGHT JOIN ensures that all rows from the Signups table are included in the result, even if there is no corresponding record in the Confirmations table. USING (user_id) : This specifies that the join should be based on the user_id column, which exists in both tables. 5. GROUP BY user_id Purpose : Groups the results by user_id . Explanation : The GROUP BY clause ensures that the aggregation (i.e., calculating the average confirmation rate) is done for each individual user, rather than for the entire dataset. \ud83d\udca1 Summary: The query calculates the confirmation rate for each user. It uses a RIGHT JOIN to include all users from the Signups table, even if they don't have a corresponding entry in the Confirmations table. The confirmation rate is calculated by counting the number query02 SELECT s . user_id , ROUND ( AVG ( IF ( c . action = 'confirmed' , 1 , 0 )), 2 ) AS confirmation_rate FROM Signups AS s LEFT OUTER JOIN Confirmations AS c ON s . user_id = c . user_id GROUP BY s . user_id ; \ud83d\ude80 Why the Query02 is Faster: LEFT JOIN is more efficient than RIGHT JOIN in this scenario. Using the IF() function for conditional logic is more efficient than CASE WHEN. The query reduces redundant data and processing by efficiently joining and aggregating the data. Indexing optimization with LEFT JOIN and direct aggregation with AVG() improve the overall performance of the query. In conclusion, the use of a LEFT JOIN , IF() function, and efficient aggregation makes this query faster compared to the previous one by minimizing data processing and enhancing the overall query optimization.","title":"1934"},{"location":"tutorials/1934/#problem-statement","text":"The confirmation rate of a user is the number of 'confirmed' messages divided by the total number of requested confirmation messages. The confirmation rate of a user that did not request any confirmation messages is 0. Round the confirmation rate to two decimal places. Write a solution to find the confirmation rate of each user. Return the result table in any order.","title":"Problem Statement"},{"location":"tutorials/1934/#solution","text":"","title":"Solution"},{"location":"tutorials/1934/#explanation-of-the-sql-query","text":"This SQL query calculates the confirmation rate for each user by determining the percentage of \"confirmed\" actions out of all possible actions for each user. The query uses the RIGHT JOIN to ensure all users from the Signups table are included, even if there is no corresponding record in the Confirmations table. query01 SELECT user_id , ROUND ( AVG ( CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END ), 2 ) AS confirmation_rate FROM Confirmations RIGHT JOIN Signups USING ( user_id ) GROUP BY user_id ;","title":"\ud83d\udcca Explanation of the SQL Query"},{"location":"tutorials/1934/#breakdown-of-the-query","text":"","title":"\ud83d\udcc8 Breakdown of the Query"},{"location":"tutorials/1934/#sql-query-breakdown","text":"","title":"\ud83d\udd0eSQL Query Breakdown"},{"location":"tutorials/1934/#1-select-user_id","text":"Purpose : Selects the user_id column from the result set. Explanation : This part of the query retrieves the unique identifier for each user in the final result.","title":"1. SELECT user_id,"},{"location":"tutorials/1934/#2-roundavgcase-when-action-confirmed-then-1-else-0-end-2-as-confirmation_rate","text":"Purpose : Calculates the confirmation rate for each user and rounds the result to 2 decimal places. Explanation : CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END : This conditional expression checks if the action is 'confirmed' . If the action is 'confirmed' , it returns 1 . Otherwise, it returns 0 . AVG() : The AVG() function calculates the average of the 1 s and 0 s, effectively computing the confirmation rate. The confirmation rate is the percentage of times the action was 'confirmed' compared to all actions for each user. ROUND(..., 2) : This rounds the calculated average (confirmation rate) to 2 decimal places , making the result more readable. AS confirmation_rate : Aliases the resulting column as confirmation_rate , which will be used in the output.","title":"2. ROUND(AVG(CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END), 2) AS confirmation_rate"},{"location":"tutorials/1934/#3-from-confirmations","text":"Purpose : Specifies the source table for the data. Explanation : The query retrieves data from the Confirmations table, which stores records of user actions, such as whether an action was confirmed.","title":"3. FROM Confirmations"},{"location":"tutorials/1934/#4-right-join-signups-using-user_id","text":"Purpose : Performs a RIGHT JOIN between the Confirmations table and the Signups table using the user_id column. Explanation : RIGHT JOIN ensures that all rows from the Signups table are included in the result, even if there is no corresponding record in the Confirmations table. USING (user_id) : This specifies that the join should be based on the user_id column, which exists in both tables.","title":"4. RIGHT JOIN Signups USING (user_id)"},{"location":"tutorials/1934/#5-group-by-user_id","text":"Purpose : Groups the results by user_id . Explanation : The GROUP BY clause ensures that the aggregation (i.e., calculating the average confirmation rate) is done for each individual user, rather than for the entire dataset.","title":"5. GROUP BY user_id"},{"location":"tutorials/1934/#summary","text":"The query calculates the confirmation rate for each user. It uses a RIGHT JOIN to include all users from the Signups table, even if they don't have a corresponding entry in the Confirmations table. The confirmation rate is calculated by counting the number query02 SELECT s . user_id , ROUND ( AVG ( IF ( c . action = 'confirmed' , 1 , 0 )), 2 ) AS confirmation_rate FROM Signups AS s LEFT OUTER JOIN Confirmations AS c ON s . user_id = c . user_id GROUP BY s . user_id ;","title":"\ud83d\udca1 Summary:"},{"location":"tutorials/1934/#why-the-query02-is-faster","text":"LEFT JOIN is more efficient than RIGHT JOIN in this scenario. Using the IF() function for conditional logic is more efficient than CASE WHEN. The query reduces redundant data and processing by efficiently joining and aggregating the data. Indexing optimization with LEFT JOIN and direct aggregation with AVG() improve the overall performance of the query. In conclusion, the use of a LEFT JOIN , IF() function, and efficient aggregation makes this query faster compared to the previous one by minimizing data processing and enhancing the overall query optimization.","title":"\ud83d\ude80 Why the Query02 is Faster:"},{"location":"tutorials/2356/","text":"2356. Number of Unique Subjects Taught by Each Teacher Problem Statement Write a solution to calculate the number of unique subjects each teacher teaches in the university. Return the result table in any order. The result format is shown in the following example. Solution The provided solution utilizes a simple SELECT with GROUP BY statement combined with a DISTINCT & COUNT() function: query:01 \u2705 SELECT teacher_id , COUNT ( DISTINCT ( subject_id ) ) AS cnt FROM Teacher GROUP BY teacher_id query:02 select teacher_id , count ( distinct ( subject_id )) as cnt from Teacher group by 1 ; \ud83e\udde0 Explanation Part Purpose SELECT teacher_id, Selects the teacher_id from the Teacher table. COUNT(DISTINCT(subject_id)) AS cnt Counts the number of unique subjects taught by each teacher and names it cnt . FROM Teacher Specifies the source table: Teacher . GROUP BY teacher_id Groups the rows by teacher so that the count is calculated per teacher instead of globally. \ud83d\udcc8 Step-by-Step Breakdown \u2705 Group all rows by teacher_id. \u2705 For each group, count the distinct subject_id values. \u2705 Output: teacher_id , Number of unique subjects taught (cnt). \ud83d\udee0 Why Query 1 was faster? Simpler Parsing In Query 1, MySQL immediately knows: \"Group by teacher_id.\" In Query 2, MySQL must first resolve: \"What is column 1?\" \u2192 Then realize it's teacher_id \u2192 Then group by it. That extra resolution step can add a tiny bit of overhead. \u26a1 Quick Tip: \ud83d\udc49 Best Practice: - Always use explicit column names in GROUP BY , ORDER BY , etc. - It\u2019s faster, more readable, and future-proof. When writing SQL queries, using the actual column name in the GROUP BY clause is often faster and more efficient than using a column position (number). \u2705 Explanation: GROUP BY 1 groups by the first column listed in the SELECT statement ( teacher_id ). MySQL must first resolve what column 1 refers to. Adds a tiny extra parsing step. MySQL may not immediately recognize indexes or optimize as aggressively.Slightly slower in some cases.","title":"2356"},{"location":"tutorials/2356/#problem-statement","text":"Write a solution to calculate the number of unique subjects each teacher teaches in the university. Return the result table in any order. The result format is shown in the following example.","title":"Problem Statement"},{"location":"tutorials/2356/#solution","text":"The provided solution utilizes a simple SELECT with GROUP BY statement combined with a DISTINCT & COUNT() function: query:01 \u2705 SELECT teacher_id , COUNT ( DISTINCT ( subject_id ) ) AS cnt FROM Teacher GROUP BY teacher_id query:02 select teacher_id , count ( distinct ( subject_id )) as cnt from Teacher group by 1 ;","title":"Solution"},{"location":"tutorials/2356/#explanation","text":"Part Purpose SELECT teacher_id, Selects the teacher_id from the Teacher table. COUNT(DISTINCT(subject_id)) AS cnt Counts the number of unique subjects taught by each teacher and names it cnt . FROM Teacher Specifies the source table: Teacher . GROUP BY teacher_id Groups the rows by teacher so that the count is calculated per teacher instead of globally.","title":"\ud83e\udde0 Explanation"},{"location":"tutorials/2356/#step-by-step-breakdown","text":"\u2705 Group all rows by teacher_id. \u2705 For each group, count the distinct subject_id values. \u2705 Output: teacher_id , Number of unique subjects taught (cnt).","title":"\ud83d\udcc8 Step-by-Step Breakdown"},{"location":"tutorials/2356/#why-query-1-was-faster","text":"Simpler Parsing In Query 1, MySQL immediately knows: \"Group by teacher_id.\" In Query 2, MySQL must first resolve: \"What is column 1?\" \u2192 Then realize it's teacher_id \u2192 Then group by it. That extra resolution step can add a tiny bit of overhead.","title":"\ud83d\udee0 Why Query 1 was faster?"},{"location":"tutorials/2356/#quick-tip","text":"\ud83d\udc49 Best Practice: - Always use explicit column names in GROUP BY , ORDER BY , etc. - It\u2019s faster, more readable, and future-proof. When writing SQL queries, using the actual column name in the GROUP BY clause is often faster and more efficient than using a column position (number).","title":"\u26a1 Quick Tip:"},{"location":"tutorials/2356/#explanation_1","text":"GROUP BY 1 groups by the first column listed in the SELECT statement ( teacher_id ). MySQL must first resolve what column 1 refers to. Adds a tiny extra parsing step. MySQL may not immediately recognize indexes or optimize as aggressively.Slightly slower in some cases.","title":"\u2705 Explanation:"},{"location":"tutorials/create/","text":"\ud83d\udcda MySQL 1.1: CREATE DATABASE Statement \ud83d\udcda MySQL 1.2: CREATE TABLE Statement \ud83d\udcda References MySQL CREATE Database Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 1.1: CREATE DATABASE Statement"},{"location":"tutorials/create/#mysql-11-create-database-statement","text":"","title":"\ud83d\udcda MySQL 1.1: CREATE DATABASE Statement"},{"location":"tutorials/create/#mysql-12-create-table-statement","text":"","title":"\ud83d\udcda MySQL 1.2: CREATE TABLE Statement"},{"location":"tutorials/create/#references","text":"MySQL CREATE Database Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/createdb/","text":"\ud83d\udcda MySQL 1.1: CREATE DATABASE Statement The CREATE DATABASE statement in MySQL is used to create a new database where you can later create tables, views, and store data. Let's learn it with a simple example: Example: Create a Database Named demo CREATE DATABASE IF NOT EXISTS demo ; CREATE DATABASE: CREATE DATABASE command creates a new database in the MySQL server. demo : This is the name of the new database.You can choose any valid name, but it must be unique (not already existing). Naming Rules: Use only letters, numbers, and underscores (_).Avoid using spaces or special characters. How to See All Databases SHOW DATABASES ; Displaying Table Structure DESCRIBE employees ; \ud83d\udcda References MySQL CREATE Database Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 1.1: CREATE DATABASE Statement"},{"location":"tutorials/createdb/#mysql-11-create-database-statement","text":"The CREATE DATABASE statement in MySQL is used to create a new database where you can later create tables, views, and store data. Let's learn it with a simple example:","title":"\ud83d\udcda MySQL 1.1: CREATE DATABASE Statement"},{"location":"tutorials/createdb/#example-create-a-database-named-demo","text":"CREATE DATABASE IF NOT EXISTS demo ;","title":"Example: Create a Database Named demo"},{"location":"tutorials/createdb/#create-database","text":"CREATE DATABASE command creates a new database in the MySQL server. demo : This is the name of the new database.You can choose any valid name, but it must be unique (not already existing).","title":"CREATE DATABASE:"},{"location":"tutorials/createdb/#naming-rules","text":"Use only letters, numbers, and underscores (_).Avoid using spaces or special characters.","title":"Naming Rules:"},{"location":"tutorials/createdb/#how-to-see-all-databases","text":"SHOW DATABASES ;","title":"How to See All Databases"},{"location":"tutorials/createdb/#displaying-table-structure","text":"DESCRIBE employees ;","title":"Displaying Table Structure"},{"location":"tutorials/createdb/#references","text":"MySQL CREATE Database Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/createtb/","text":"\ud83d\udcda MySQL 1.2: CREATE TABLE Statement For now we will create an example table, later we will make necessary improvents. The CREATE TABLE statement in MySQL is used to create a new table in a database. Let's understand it using a real-world example: Example: employees Table CREATE TABLE IF NOT EXISTS employees ( EMPLOYEE_ID int ( 6 ) PRIMARY KEY AUTO_INCREMENT , FIRST_NAME varchar ( 20 ), LAST_NAME varchar ( 25 ) NOT NULL , EMAIL varchar ( 25 ) NOT NULL , PHONE_NUMBER varchar ( 20 ), HIRE_DATE date NOT NULL , JOB_ID varchar ( 10 ) NOT NULL , SALARY decimal ( 8 , 2 ), COMMISSION_PCT decimal ( 2 , 2 ), MANAGER_ID int ( 6 ), DEPTARTMENT_ID int ( 4 ) ); Key Concepts Highlighted: PRIMARY KEY : Uniquely identifies each record in the table. AUTO_INCREMENT : Automatically increases EMPLOYEE_ID for each new row. NOT NULL : Column must always have a value (cannot be left empty). varchar(n) : Stores a variable-length string with a maximum of n characters. decimal(m,d) : Numbers with fixed precision. m = total digits, d = digits after decimal point. date : Stores dates in YYYY-MM-DD format. \ud83d\udcda References MySQL CREATE TABLE Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 1.2: CREATE TABLE Statement"},{"location":"tutorials/createtb/#mysql-12-create-table-statement","text":"For now we will create an example table, later we will make necessary improvents. The CREATE TABLE statement in MySQL is used to create a new table in a database. Let's understand it using a real-world example:","title":"\ud83d\udcda MySQL 1.2: CREATE TABLE Statement"},{"location":"tutorials/createtb/#example-employees-table","text":"CREATE TABLE IF NOT EXISTS employees ( EMPLOYEE_ID int ( 6 ) PRIMARY KEY AUTO_INCREMENT , FIRST_NAME varchar ( 20 ), LAST_NAME varchar ( 25 ) NOT NULL , EMAIL varchar ( 25 ) NOT NULL , PHONE_NUMBER varchar ( 20 ), HIRE_DATE date NOT NULL , JOB_ID varchar ( 10 ) NOT NULL , SALARY decimal ( 8 , 2 ), COMMISSION_PCT decimal ( 2 , 2 ), MANAGER_ID int ( 6 ), DEPTARTMENT_ID int ( 4 ) );","title":"Example: employees Table"},{"location":"tutorials/createtb/#key-concepts-highlighted","text":"PRIMARY KEY : Uniquely identifies each record in the table. AUTO_INCREMENT : Automatically increases EMPLOYEE_ID for each new row. NOT NULL : Column must always have a value (cannot be left empty). varchar(n) : Stores a variable-length string with a maximum of n characters. decimal(m,d) : Numbers with fixed precision. m = total digits, d = digits after decimal point. date : Stores dates in YYYY-MM-DD format.","title":"Key Concepts Highlighted:"},{"location":"tutorials/createtb/#references","text":"MySQL CREATE TABLE Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/insert/","text":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Single Row) \ud83d\udcda MySQL 2.1: INSERT INTO Statement (Multiple Row) \ud83d\udcda References MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Single Row)"},{"location":"tutorials/insert/#mysql-21-insert-into-statement-single-row","text":"","title":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Single Row)"},{"location":"tutorials/insert/#mysql-21-insert-into-statement-multiple-row","text":"","title":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Multiple Row)"},{"location":"tutorials/insert/#_1","text":"","title":""},{"location":"tutorials/insert/#references","text":"MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/insertml/","text":"\ud83d\udcda MySQL 2.2: INSERT INTO Statement (Multiple Rows) In MySQL, you can insert multiple rows at once using a single INSERT INTO statement. This method is faster and more efficient than inserting rows one by one. \u2728 Basic Syntax INSERT INTO table_name ( column1 , column2 , column3 , ...) VALUES ( value1a , value2a , value3a , ...), ( value1b , value2b , value3b , ...), ( value1c , value2c , value3c , ...); Key concepts table_name : Name of the table. Each set of parentheses () contains the values for one row. -Multiple rows are separated by commas , Insert multiple employees at once: INSERT INTO employees ( FIRST_NAME , LAST_NAME , EMAIL , PHONE_NUMBER , HIRE_DATE , JOB_ID , SALARY , COMMISSION_PCT , MANAGER_ID , DEPARTMENT_ID ) VALUES ( 'Alice' , 'Brown' , 'alice.brown@example.com' , '111-222-3333' , '2024-04-26' , 'HR02' , 55000 . 00 , 0 . 03 , 101 , 20 ), ( 'Bob' , 'Green' , 'bob.green@example.com' , '444-555-6666' , '2024-04-26' , 'DEV02' , 70000 . 00 , 0 . 05 , 102 , 30 ), ( 'Charlie' , 'White' , 'charlie.white@example.com' , '777-888-9999' , '2024-04-26' , 'SALES01' , 65000 . 00 , 0 . 04 , 103 , 40 ); Key Concepts: Three rows are inserted with a single command. EMPLOYEE_ID is auto-generated for each inserted row. Insert Without Listing Columns You can insert multiple rows without listing column names (be careful with the order) INSERT INTO employees VALUES ( NULL , 'David' , 'King' , 'david.king@example.com' , '123-123-1234' , '2024-04-26' , 'MGR01' , 80000 . 00 , 0 . 06 , 100 , 50 ), ( NULL , 'Eva' , 'Stone' , 'eva.stone@example.com' , '321-321-4321' , '2024-04-26' , 'DEV03' , 62000 . 00 , 0 . 02 , 101 , 20 ); \ud83d\udcda References MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 2.2: INSERT INTO Statement (Multiple Rows)"},{"location":"tutorials/insertml/#mysql-22-insert-into-statement-multiple-rows","text":"In MySQL, you can insert multiple rows at once using a single INSERT INTO statement. This method is faster and more efficient than inserting rows one by one.","title":"\ud83d\udcda MySQL 2.2: INSERT INTO Statement (Multiple Rows)"},{"location":"tutorials/insertml/#basic-syntax","text":"INSERT INTO table_name ( column1 , column2 , column3 , ...) VALUES ( value1a , value2a , value3a , ...), ( value1b , value2b , value3b , ...), ( value1c , value2c , value3c , ...);","title":"\u2728 Basic Syntax"},{"location":"tutorials/insertml/#key-concepts","text":"table_name : Name of the table. Each set of parentheses () contains the values for one row. -Multiple rows are separated by commas ,","title":"Key concepts"},{"location":"tutorials/insertml/#insert-multiple-employees-at-once","text":"INSERT INTO employees ( FIRST_NAME , LAST_NAME , EMAIL , PHONE_NUMBER , HIRE_DATE , JOB_ID , SALARY , COMMISSION_PCT , MANAGER_ID , DEPARTMENT_ID ) VALUES ( 'Alice' , 'Brown' , 'alice.brown@example.com' , '111-222-3333' , '2024-04-26' , 'HR02' , 55000 . 00 , 0 . 03 , 101 , 20 ), ( 'Bob' , 'Green' , 'bob.green@example.com' , '444-555-6666' , '2024-04-26' , 'DEV02' , 70000 . 00 , 0 . 05 , 102 , 30 ), ( 'Charlie' , 'White' , 'charlie.white@example.com' , '777-888-9999' , '2024-04-26' , 'SALES01' , 65000 . 00 , 0 . 04 , 103 , 40 );","title":"Insert multiple employees at once:"},{"location":"tutorials/insertml/#key-concepts_1","text":"Three rows are inserted with a single command. EMPLOYEE_ID is auto-generated for each inserted row.","title":"Key Concepts:"},{"location":"tutorials/insertml/#insert-without-listing-columns","text":"You can insert multiple rows without listing column names (be careful with the order) INSERT INTO employees VALUES ( NULL , 'David' , 'King' , 'david.king@example.com' , '123-123-1234' , '2024-04-26' , 'MGR01' , 80000 . 00 , 0 . 06 , 100 , 50 ), ( NULL , 'Eva' , 'Stone' , 'eva.stone@example.com' , '321-321-4321' , '2024-04-26' , 'DEV03' , 62000 . 00 , 0 . 02 , 101 , 20 );","title":"Insert Without Listing Columns"},{"location":"tutorials/insertml/#references","text":"MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/insertsg/","text":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Single Row) The INSERT INTO statement is used to add new rows into a table in MySQL. Let's learn how to insert a single row step-by-step! \u2728 Basic Syntax INSERT INTO table_name ( column1 , column2 , column3 , ...) VALUES ( value1 , value2 , value3 , ...); EXample INSERT INTO employees ( FIRST_NAME , LAST_NAME , EMAIL , PHONE_NUMBER , HIRE_DATE , JOB_ID , SALARY , COMMISSION_PCT , MANAGER_ID , DEPARTMENT_ID ) VALUES ( 'John' , 'Doe' , 'john.doe@example.com' , '123-456-7890' , '2024-04-26' , 'DEV01' , 60000 . 00 , 0 . 05 , 101 , 10 ); Key Points to Remember Always list column names in the same order as the values. String values (varchar, date) must be enclosed in single quotes '...' Numeric values (int, decimal) are written without quotes. You can omit columns that have default values or are set to auto-increment. Insert Without Specifying Columns If you want to insert values into all columns (except auto-increment ones) in exact order, you can simplify: INSERT INTO employees VALUES ( NULL , 'Jane' , 'Smith' , 'jane.smith@example.com' , '987-654-3210' , '2024-04-26' , 'HR01' , 50000 . 00 , 0 . 02 , 102 , 20 ); \ud83d\udcda References MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Single Row)"},{"location":"tutorials/insertsg/#mysql-21-insert-into-statement-single-row","text":"The INSERT INTO statement is used to add new rows into a table in MySQL. Let's learn how to insert a single row step-by-step!","title":"\ud83d\udcda MySQL 2.1: INSERT INTO Statement (Single Row)"},{"location":"tutorials/insertsg/#basic-syntax","text":"INSERT INTO table_name ( column1 , column2 , column3 , ...) VALUES ( value1 , value2 , value3 , ...);","title":"\u2728 Basic Syntax"},{"location":"tutorials/insertsg/#example","text":"INSERT INTO employees ( FIRST_NAME , LAST_NAME , EMAIL , PHONE_NUMBER , HIRE_DATE , JOB_ID , SALARY , COMMISSION_PCT , MANAGER_ID , DEPARTMENT_ID ) VALUES ( 'John' , 'Doe' , 'john.doe@example.com' , '123-456-7890' , '2024-04-26' , 'DEV01' , 60000 . 00 , 0 . 05 , 101 , 10 );","title":"EXample"},{"location":"tutorials/insertsg/#key-points-to-remember","text":"Always list column names in the same order as the values. String values (varchar, date) must be enclosed in single quotes '...' Numeric values (int, decimal) are written without quotes. You can omit columns that have default values or are set to auto-increment.","title":"Key Points to Remember"},{"location":"tutorials/insertsg/#insert-without-specifying-columns","text":"If you want to insert values into all columns (except auto-increment ones) in exact order, you can simplify: INSERT INTO employees VALUES ( NULL , 'Jane' , 'Smith' , 'jane.smith@example.com' , '987-654-3210' , '2024-04-26' , 'HR01' , 50000 . 00 , 0 . 02 , 102 , 20 );","title":"Insert Without Specifying Columns"},{"location":"tutorials/insertsg/#references","text":"MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/select/","text":"\ud83d\udcda MySQL 3.1: SELECT PART 01 \ud83d\udcda MySQL 3.2: SELECT PART 02 ) \ud83d\udcda References MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL 3.1: SELECT PART 01"},{"location":"tutorials/select/#mysql-31-select-part-01","text":"","title":"\ud83d\udcda MySQL 3.1: SELECT PART 01"},{"location":"tutorials/select/#mysql-32-select-part-02","text":"","title":"\ud83d\udcda MySQL 3.2: SELECT PART 02)"},{"location":"tutorials/select/#references","text":"MySQL INSERT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"},{"location":"tutorials/selectp1/","text":"\ud83d\udcda MySQL: SELECT Statement Comprehensive Tutorial The SELECT statement in MySQL is used to retrieve data from one or more tables. It is one of the most important and frequently used SQL commands. Mastering SELECT is essential for querying and analyzing database information effectively. \ud83d\ude80 \u2728 Basic Syntax SELECT * | { [ DISTINCT ] column | expression [ alias ], ... } FROM table_name ; Simple Example: SELECT column1 , column2 , ... FROM table_name ; - * selects all columns. DISTINCT removes duplicate results. alias allows you to rename a column or expression temporarily. \ud83d\udccb Selecting All Columns Use the * wildcard to retrieve every column: SELECT * FROM employees ; - \u2705 This returns all the data for every employee in the employees table. \ud83d\udccb Selecting Specific Columns Select only the needed columns: SELECT FIRST_NAME , LAST_NAME , EMAIL FROM employees ; \u2705 Fetches only FIRST_NAME, LAST_NAME, and EMAIL columns, making queries faster and results cleaner. \ud83e\uddee Using Arithmetic Operators in SELECT You can perform calculations inside your SELECT statements: SELECT last_name , salary , 12 * ( salary + 100 ) FROM employees ; - \u2705 Calculates the annual salary plus $100 bonus. \u270f\ufe0f Using Column Aliases Give a friendly name to columns or calculations using aliases: SELECT last_name AS \"Name\" , salary * 12 AS \"Annual Salary\" FROM employees ; \u2705 Aliases make output easier to understand. \ud83d\udd17 Using Concatenation Operator You can combine strings using the CONCAT function: SELECT CONCAT ( last_name , ' is a ' , job_id ) AS \"Employee Details\" FROM employees ; \u2705 Creates a readable string about each employee's job. \ud83d\udeab Eliminating Duplicate Rows with DISTINCT Remove duplicates using DISTINCT: SELECT DISTINCT department_id FROM employees ; \u2705 Returns each department ID only once, even if multiple employees belong to the same department. \ud83d\udd0d Filtering Results Using WHERE Clause Fetch rows that meet a specific condition: SELECT FIRST_NAME , LAST_NAME FROM employees WHERE JOB_ID = 'DEV02' ; - \u2705 Returns employees whose job ID is DEV02. \ud83c\udfaf Filtering Examples -Limiting Results by Department SELECT employee_id , last_name , job_id , department_id FROM employees WHERE department_id = 90 ; Filtering with Strings and Dates SELECT last_name , job_id , department_id FROM employees WHERE last_name = 'WHALEN' ; - String comparisons must match exactly (case-sensitive by default). Using Comparison Operators SELECT last_name , salary FROM employees WHERE salary <= 3000 ; - \u2705 Returns employees earning $3000 or less. Using BETWEEN Operator SELECT last_name , salary FROM employees WHERE salary BETWEEN 2500 AND 3500 ; - \u2705 Selects salaries between 2500 and 3500 inclusive. Using IN Operator SELECT employee_id , last_name , salary , manager_id FROM employees WHERE manager_id IN ( 100 , 101 , 201 ); - \u2705 Returns employees managed by either 100, 101, or 201. - \ud83d\udcc8 Sorting Results with ORDER BY Sort the output in ascending (ASC) or descending (DESC) order: SELECT FIRST_NAME , SALARY FROM employees ORDER BY SALARY DESC ; - ASC is default (smallest to largest). - DESC sorts largest to smallest. - \u2705 Retrieves employees sorted by highest salary first. \ud83e\udde9 Sorting by Multiple Columns You can sort first by one column, then by another: SELECT last_name , department_id , salary FROM employees ORDER BY department_id ASC , salary DESC ; - \u2705 First sorts by department_id, then within each department sorts by salary descending. \ud83d\ude80 Combining Clauses Example Use WHERE, ORDER BY, and LIMIT together: SELECT FIRST_NAME , LAST_NAME , SALARY FROM employees WHERE SALARY > 60000 ORDER BY SALARY DESC LIMIT 3 ; - \u2705 Returns the top 3 employees earning above 60,000, ordered by highest salary first. \ud83d\udd25 Key Takeaways SELECT is used to fetch data. Use WHERE to filter rows. Use ORDER BY to sort rows. Use DISTINCT to remove duplicates. Use LIMIT to restrict the number of rows returned. Use aliases to make outputs more readable. -Operators like BETWEEN , IN , CONCAT , and arithmetic help in building powerful queries. Leet code problem : 1683. Invalid Tweets 2356. Number of Unique Subjects Taught by Each Teacher 1517. Find Users With Valid E-Mails 1934. Confirmation Rate 1907. Count Salary Categories \ud83d\udcda References MySQL SELECT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda MySQL: SELECT Statement Comprehensive Tutorial"},{"location":"tutorials/selectp1/#mysql-select-statement-comprehensive-tutorial","text":"The SELECT statement in MySQL is used to retrieve data from one or more tables. It is one of the most important and frequently used SQL commands. Mastering SELECT is essential for querying and analyzing database information effectively. \ud83d\ude80","title":"\ud83d\udcda MySQL: SELECT Statement Comprehensive Tutorial"},{"location":"tutorials/selectp1/#basic-syntax","text":"SELECT * | { [ DISTINCT ] column | expression [ alias ], ... } FROM table_name ;","title":"\u2728 Basic Syntax"},{"location":"tutorials/selectp1/#simple-example","text":"SELECT column1 , column2 , ... FROM table_name ; - * selects all columns. DISTINCT removes duplicate results. alias allows you to rename a column or expression temporarily.","title":"Simple Example:"},{"location":"tutorials/selectp1/#selecting-all-columns","text":"Use the * wildcard to retrieve every column: SELECT * FROM employees ; - \u2705 This returns all the data for every employee in the employees table.","title":"\ud83d\udccb Selecting All Columns"},{"location":"tutorials/selectp1/#selecting-specific-columns","text":"Select only the needed columns: SELECT FIRST_NAME , LAST_NAME , EMAIL FROM employees ; \u2705 Fetches only FIRST_NAME, LAST_NAME, and EMAIL columns, making queries faster and results cleaner.","title":"\ud83d\udccb Selecting Specific Columns"},{"location":"tutorials/selectp1/#using-arithmetic-operators-in-select","text":"You can perform calculations inside your SELECT statements: SELECT last_name , salary , 12 * ( salary + 100 ) FROM employees ; - \u2705 Calculates the annual salary plus $100 bonus.","title":"\ud83e\uddee Using Arithmetic Operators in SELECT"},{"location":"tutorials/selectp1/#using-column-aliases","text":"Give a friendly name to columns or calculations using aliases: SELECT last_name AS \"Name\" , salary * 12 AS \"Annual Salary\" FROM employees ; \u2705 Aliases make output easier to understand.","title":"\u270f\ufe0f Using Column Aliases"},{"location":"tutorials/selectp1/#using-concatenation-operator","text":"You can combine strings using the CONCAT function: SELECT CONCAT ( last_name , ' is a ' , job_id ) AS \"Employee Details\" FROM employees ; \u2705 Creates a readable string about each employee's job.","title":"\ud83d\udd17 Using Concatenation Operator"},{"location":"tutorials/selectp1/#eliminating-duplicate-rows-with-distinct","text":"Remove duplicates using DISTINCT: SELECT DISTINCT department_id FROM employees ; \u2705 Returns each department ID only once, even if multiple employees belong to the same department.","title":"\ud83d\udeab Eliminating Duplicate Rows with DISTINCT"},{"location":"tutorials/selectp1/#filtering-results-using-where-clause","text":"Fetch rows that meet a specific condition: SELECT FIRST_NAME , LAST_NAME FROM employees WHERE JOB_ID = 'DEV02' ; - \u2705 Returns employees whose job ID is DEV02.","title":"\ud83d\udd0d Filtering Results Using WHERE Clause"},{"location":"tutorials/selectp1/#filtering-examples","text":"-Limiting Results by Department SELECT employee_id , last_name , job_id , department_id FROM employees WHERE department_id = 90 ;","title":"\ud83c\udfaf Filtering Examples"},{"location":"tutorials/selectp1/#filtering-with-strings-and-dates","text":"SELECT last_name , job_id , department_id FROM employees WHERE last_name = 'WHALEN' ; - String comparisons must match exactly (case-sensitive by default).","title":"Filtering with Strings and Dates"},{"location":"tutorials/selectp1/#using-comparison-operators","text":"SELECT last_name , salary FROM employees WHERE salary <= 3000 ; - \u2705 Returns employees earning $3000 or less.","title":"Using Comparison Operators"},{"location":"tutorials/selectp1/#using-between-operator","text":"SELECT last_name , salary FROM employees WHERE salary BETWEEN 2500 AND 3500 ; - \u2705 Selects salaries between 2500 and 3500 inclusive.","title":"Using BETWEEN Operator"},{"location":"tutorials/selectp1/#using-in-operator","text":"SELECT employee_id , last_name , salary , manager_id FROM employees WHERE manager_id IN ( 100 , 101 , 201 ); - \u2705 Returns employees managed by either 100, 101, or 201. -","title":"Using IN Operator"},{"location":"tutorials/selectp1/#sorting-results-with-order-by","text":"Sort the output in ascending (ASC) or descending (DESC) order: SELECT FIRST_NAME , SALARY FROM employees ORDER BY SALARY DESC ; - ASC is default (smallest to largest). - DESC sorts largest to smallest. - \u2705 Retrieves employees sorted by highest salary first.","title":"\ud83d\udcc8 Sorting Results with ORDER BY"},{"location":"tutorials/selectp1/#sorting-by-multiple-columns","text":"You can sort first by one column, then by another: SELECT last_name , department_id , salary FROM employees ORDER BY department_id ASC , salary DESC ; - \u2705 First sorts by department_id, then within each department sorts by salary descending.","title":"\ud83e\udde9 Sorting by Multiple Columns"},{"location":"tutorials/selectp1/#combining-clauses-example","text":"Use WHERE, ORDER BY, and LIMIT together: SELECT FIRST_NAME , LAST_NAME , SALARY FROM employees WHERE SALARY > 60000 ORDER BY SALARY DESC LIMIT 3 ; - \u2705 Returns the top 3 employees earning above 60,000, ordered by highest salary first.","title":"\ud83d\ude80 Combining Clauses Example"},{"location":"tutorials/selectp1/#key-takeaways","text":"SELECT is used to fetch data. Use WHERE to filter rows. Use ORDER BY to sort rows. Use DISTINCT to remove duplicates. Use LIMIT to restrict the number of rows returned. Use aliases to make outputs more readable. -Operators like BETWEEN , IN , CONCAT , and arithmetic help in building powerful queries.","title":"\ud83d\udd25 Key Takeaways"},{"location":"tutorials/selectp1/#leet-code-problem","text":"1683. Invalid Tweets 2356. Number of Unique Subjects Taught by Each Teacher 1517. Find Users With Valid E-Mails 1934. Confirmation Rate 1907. Count Salary Categories","title":"Leet code problem :"},{"location":"tutorials/selectp1/#references","text":"MySQL SELECT Tutorial \u2013 MySQL Tutorial","title":"\ud83d\udcda References"}]}